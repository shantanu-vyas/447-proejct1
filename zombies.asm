.data 
maze:	.ascii
	# 0123456701234567012345670123456701234567012345670123456701234567
	 "  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",    # 0
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 1
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 2
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 3
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 4
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 5
	 "x                                                              x",    # 6
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 7
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 8
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 9
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 10
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 11
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 12
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 13
	 "x                                                              x",    # 14
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 15
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 16
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 17
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 18
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 19
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 20
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 21
	 "x                                                              x",    # 22
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 23
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 24
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 25
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 26
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 27
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 28
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 29
	 "x                                                              x",    # 30
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 31
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 32
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 33
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 34
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 35
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 36
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 37
	 "x                                                              x",    # 38
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 39
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 40
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 41
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 42
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 43
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 44
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 45
	 "x                                                              x",    # 46
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 47
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 48
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 49
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 50
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 51
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 52
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 53
	 "x                                                              x",    # 54
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 55
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 56
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 57
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 58
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 59
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 60
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 61
	 "x                                                               ",    # 62
	 "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  "     # 63
	# for each "x", turn the corresponding LED to orange.  The other LEDs should
	# be set to off.
foundX:	.asciiz "found an x \n"
called: .asciiz "called\n"
won:	.asciiz "Success! You won! Your score is "
wonTurns:	.asciiz " moves."
lost: 	.asciiz "Sorry. You were captured."
.text
#la $a0 maze
#lb $a0 0($a0)
#li $v0 11
#syscall


j poll

#jal removeOldCharacter
#addi $s0 $s0 0 #position of the person




li $v0 10
syscall

drawBoard:
	addi $sp $sp -24
	sw $s0 0($sp)
	sw $s1 4($sp)
	sw $s2 8($sp)
	sw $s3 16($sp)
	sw $ra 20($sp)
	
	la $s1 maze
	li $s2 0
	li $s3 64
	
drawBoardLoop:

	lb $s0 0($s1)
	beq $s0 120 DivAndDrawLED
	j incrementAndJump

DivAndDrawLED:
	div $s2 $s3
	mflo $a1 
	mfhi $a0
	#move $a0 $s0 
	#jal getPositionFromNumber
	#move $a0 $v1
	#move $a1 $v0
	li $a2 2
	jal _setLED
	j incrementAndJump
	
incrementAndJump:
        addi $s1 $s1 1
	addi $s2 $s2 1
	beq $s2 4096 return
	j drawBoardLoop

return:
	lw $s0 0($sp)
	lw $s1 4($sp)
	lw $s2 8($sp)
	lw $s3 16($sp)
	lw $ra 20($sp)
	addi $sp $sp 24	
        jr $ra


_setLED:
	# byte offset into display = y * 16 bytes + (x / 4)
	sll	$t0,$a1,4      # y * 16 bytes
	srl	$t1,$a0,2      # x / 4
	add	$t0,$t0,$t1    # byte offset into display
	li	$t2,0xffff0008 # base address of LED display
	add	$t0,$t2,$t0    # address of byte with the LED
	# now, compute led position in the byte and the mask for it
	andi	$t1,$a0,0x3    # remainder is led position in byte
	neg	$t1,$t1        # negate position for subtraction
	addi	$t1,$t1,3      # bit positions in reverse order
	sll	$t1,$t1,1      # led is 2 bits
	# compute two masks: one to clear field, one to set new color
	li	$t2,3		
	sllv	$t2,$t2,$t1
	not	$t2,$t2        # bit mask for clearing current color
	sllv	$t1,$a2,$t1    # bit mask for setting color
	# get current LED value, set the new field, store it back to LED
	lbu	$t3,0($t0)     # read current LED value	
	and	$t3,$t3,$t2    # clear the field for the color
	or	$t3,$t3,$t1    # set color field
	sb	$t3,0($t0)     # update display
	jr	$ra
	
	# int _getLED(int x, int y)
	#   returns the value of the LED at position (x,y)
	#
	#  arguments: $a0 holds x, $a1 holds y
	#  trashes:   $t0-$t2
	#  returns:   $v0 holds the value of the LED (0, 1, 2 or 3)
	#
_getLED:
	# byte offset into display = y * 16 bytes + (x / 4)
	sll  $t0,$a1,4      # y * 16 bytes
	srl  $t1,$a0,2      # x / 4
	add  $t0,$t0,$t1    # byte offset into display
	la   $t2,0xffff0008
	add  $t0,$t2,$t0    # address of byte with the LED
	# now, compute bit position in the byte and the mask for it
	andi $t1,$a0,0x3    # remainder is bit position in byte
	neg  $t1,$t1        # negate position for subtraction
	addi $t1,$t1,3      # bit positions in reverse order
    	sll  $t1,$t1,1      # led is 2 bits
	# load LED value, get the desired bit in the loaded byte
	lbu  $t2,0($t0)
	srlv $t2,$t2,$t1    # shift LED value to lsb position
	andi $v0,$t2,0x3    # mask off any remaining upper bits
	jr   $ra

poll:	
	beq $t9 4095 wonGame
	la	$v0,0xffff0000		# address for reading key press status
	lw	$t0,0($v0)		# read the key press status
	andi	$t0,$t0,1
	beq	$t0,$0,poll		# no key pressed
	lw	$t0,4($v0)		# read key value
	
bkey:
	addi $v0, $t0 -66
	bne $v0, $0, rkey	
	jal drawBoard
	li $t9 0 #player position
	li $t8 0 #turn counter
	move $a0 $t9 #should probably hold this somewhere other than t9 DONT USE t9 FOR TEMP
	jal drawCharacter
	#li $v0 4
	#la $a0 called
	#syscall
	j poll		
	
rkey:	addi	$v0,$t0,-227		# check for right key press
	bne	$v0,$0,lkey		# wasn't right key, so check for center
	#move char to right
	move $a0 $t9
	addi $a0 $a0 1 #add one for the if statement
	jal ifNextBlockWall
	beq $v0 0 poll #ifNextBlockWall returns false
	addi $a0 $a0 -1 #go back to original position to remove old character
	
	jal removeOldCharacter
	addi $t9 $t9 1
	move $a0 $t9	
	#li $v0 1
	#syscall
	jal drawCharacter
	j	poll


lkey:	addi	$v0,$t0,-226		# check for right key press
	bne	$v0,$0,dkey		# wasn't right key, so check for center
	#move char to right
	move $a0 $t9
	addi $a0 $a0 -1
	jal ifNextBlockWall
	beq $v0 0 poll
	addi $a0 $a0 1
	
	jal removeOldCharacter
	addi $t9 $t9 -1
	move $a0 $t9
	#li $v0 1
	#syscall
	jal drawCharacter		
	j	poll	

dkey:	addi	$v0,$t0,-225		# check for right key press
	bne	$v0,$0,ukey		# wasn't right key, so check for center
	#move char to right
	move $a0 $t9
	addi $a0 $a0 64
	jal ifNextBlockWall
	beq $v0 0 poll
	addi $a0 $a0 -64
	jal removeOldCharacter
	addi $t9 $t9 64
	move $a0 $t9
	#li $v0 1
	#syscall
	jal drawCharacter
	j	poll	
	


ukey:	addi	$v0,$t0,-224		# check for right key press
	bne	$v0,$0,poll		# wasn't right key, so check for center
	#move char to right
	move $a0 $t9
	addi $a0 $a0 -64
	jal ifNextBlockWall
	beq $v0 0 poll
	addi $a0 $a0 64

	jal removeOldCharacter
	addi $t9 $t9 -64
	move $a0 $t9
	#li $v0 1
	#syscall
	jal drawCharacter
	j	poll		

										

#takes next block in a0 as parameter	
ifNextBlockWall:
	addi $sp $sp -8
	sw $ra 0($sp)
	sw $t0 4($sp)
	move $t8 $a0
	#a0 is a number
	li $t0 64
	div $a0 $t0
	mflo $a1 
	mfhi $a0
	
	jal _getLED
	beq $v0 2 returnFalse
	j returnTrue
	

returnFalse:
	lw $ra 0($sp)
	lw $t0 4($sp)
	addi $sp $sp 8
	li $v0 0
	move $a0 $t8
	jr $ra
returnTrue:
	lw $ra 0($sp)
	lw $t0 4($sp)
	addi $sp $sp 8
	li $v0 1
	move $a0 $t8
	jr $ra
#a0 paramter
removeOldCharacter:
	addi $sp $sp -4
	sw $ra 0($sp)
	li $t0 64
	div $a0 $t0
	mflo $a1 
	mfhi $a0
	li $a2 0
	jal _setLED
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra

#a0 parameter for place
drawCharacter:
	addi $sp $sp -4
	sw $ra 0($sp)
	li $t0 64
	div $a0 $t0 
	mflo $a1 
	mfhi $a0
	li $a2 3
	jal _setLED

	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra

wonGame:
	la $a0 won
	li $v0 4
	syscall
	move $a0 $t8
	li $v0 1
	syscall
	la $a0 wonTurns
	li $v0 4
	syscall
	li $v0 10
	syscall
lostGame:
	la $a0 lost
	li $v0 4
	syscall
	li $v0 10
	syscall