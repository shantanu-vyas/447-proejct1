.data 
maze:	.ascii
	# 0123456701234567012345670123456701234567012345670123456701234567
	 "  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",    # 0
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 1
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 2
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 3
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 4
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 5
	 "x                                                              x",    # 6
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 7
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 8
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 9
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 10
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 11
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 12
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 13
	 "x                                                              x",    # 14
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 15
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 16
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 17
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 18
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 19
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 20
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 21
	 "x                                                              x",    # 22
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 23
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 24
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 25
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 26
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 27
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 28
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 29
	 "x                                                              x",    # 30
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 31
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 32
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 33
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 34
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 35
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 36
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 37
	 "x                                                              x",    # 38
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 39
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 40
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 41
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 42
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 43
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 44
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 45
	 "x                                                              x",    # 46
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 47
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 48
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 49
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 50
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 51
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 52
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 53
	 "x                                                              x",    # 54
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 55
	 "x xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxxx xxxxxx",    # 56
	 "x      xx      xx      xx      xx      xx      xx      xx      x",    # 57
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 58
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 59
	 "x x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x xx x  x x",    # 60
	 "x xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx xx xxxx x",    # 61
	 "x                                                               ",    # 62
	 "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  "     # 63
	# for each "x", turn the corresponding LED to orange.  The other LEDs should
	# be set to off.
foundX:	.asciiz "found an x \n"
called: .asciiz "called\n"
won:	.asciiz "Success! You won! Your score is "
wonTurns:	.asciiz " moves."
lost: 	.asciiz "Sorry. You were captured."
newline:	.asciiz "\n"

zombie1Position:	.word 73
zombie1Dir: 		.byte 0 1 2 3
zombie2Position:	.word 1125
zombie2Dir: 		.byte 0 1 2 3
zombie3Position:	.word 2140
zombie3Dir:		.byte 0 1 2 3
zombie4Position:	.word 3897
zombie4Dir: 		.byte 0 1 2 3

zombie1Time:	.word 0
zombie2Time:	.word 0
zombie3Time:	.word 0
zombie4Time:	.word 0

quadrant1MinX:	.byte 0
quadrant1MinY:	.byte 0
quadrant1MaxX:	.byte 32
quadrant1MaxY:	.byte 32

quadrant2MinX:	.byte 32
quadrant2MinY:	.byte 0
quadrant2MaxX:	.byte 64
quadrant2MaxY:	.byte 32

quadrant3MinX:	.byte 0
quadrant3MinY:	.byte 32
quadrant3MaxX:	.byte 32
quadrant3MaxY:	.byte 64

quadrant4MinX:	.byte 32
quadrant4MinY:	.byte 32
quadrant4MaxX:	.byte 64
quadrant4MaxY:	.byte 64

.text

#jal setZombie1TimeCurrent
#jal getTime
#move $t1 $v0
#li $a0 400
#li $v0 32
#syscall
#move $a0 $t1
#jal getTimeDifference
#move $a0 $v0
#li $v0 1
#syscall

#jal printNewLine
#jal hasZombie1TimeElapsed
#move $a0 $v0
#li $v0 1
#syscall


j poll

#jal moveZombie1


li $v0 10
syscall

drawBoard:
	addi $sp $sp -24
	sw $s0 0($sp)
	sw $s1 4($sp)
	sw $s2 8($sp)
	sw $s3 16($sp)
	sw $ra 20($sp)
	
	la $s1 maze
	li $s2 0
	li $s3 64
	
drawBoardLoop:

	lb $s0 0($s1)
	beq $s0 120 DivAndDrawLED
	j incrementAndJump

DivAndDrawLED:
	div $s2 $s3
	mflo $a1 
	mfhi $a0
	#move $a0 $s0 
	#jal getPositionFromNumber
	#move $a0 $v1
	#move $a1 $v0
	li $a2 2
	jal _setLED
	j incrementAndJump
	
incrementAndJump:
        addi $s1 $s1 1
	addi $s2 $s2 1
	beq $s2 4096 return
	j drawBoardLoop

return:
	lw $s0 0($sp)
	lw $s1 4($sp)
	lw $s2 8($sp)
	lw $s3 16($sp)
	lw $ra 20($sp)
	addi $sp $sp 24	
        jr $ra


_setLED:
	# byte offset into display = y * 16 bytes + (x / 4)
	sll	$t0,$a1,4      # y * 16 bytes
	srl	$t1,$a0,2      # x / 4
	add	$t0,$t0,$t1    # byte offset into display
	li	$t2,0xffff0008 # base address of LED display
	add	$t0,$t2,$t0    # address of byte with the LED
	# now, compute led position in the byte and the mask for it
	andi	$t1,$a0,0x3    # remainder is led position in byte
	neg	$t1,$t1        # negate position for subtraction
	addi	$t1,$t1,3      # bit positions in reverse order
	sll	$t1,$t1,1      # led is 2 bits
	# compute two masks: one to clear field, one to set new color
	li	$t2,3		
	sllv	$t2,$t2,$t1
	not	$t2,$t2        # bit mask for clearing current color
	sllv	$t1,$a2,$t1    # bit mask for setting color
	# get current LED value, set the new field, store it back to LED
	lbu	$t3,0($t0)     # read current LED value	
	and	$t3,$t3,$t2    # clear the field for the color
	or	$t3,$t3,$t1    # set color field
	sb	$t3,0($t0)     # update display
	jr	$ra
	
	# int _getLED(int x, int y)
	#   returns the value of the LED at position (x,y)
	#
	#  arguments: $a0 holds x, $a1 holds y
	#  trashes:   $t0-$t2
	#  returns:   $v0 holds the value of the LED (0, 1, 2 or 3)
	#
_getLED:
	# byte offset into display = y * 16 bytes + (x / 4)
	sll  $t0,$a1,4      # y * 16 bytes
	srl  $t1,$a0,2      # x / 4
	add  $t0,$t0,$t1    # byte offset into display
	la   $t2,0xffff0008
	add  $t0,$t2,$t0    # address of byte with the LED
	# now, compute bit position in the byte and the mask for it
	andi $t1,$a0,0x3    # remainder is bit position in byte
	neg  $t1,$t1        # negate position for subtraction
	addi $t1,$t1,3      # bit positions in reverse order
    	sll  $t1,$t1,1      # led is 2 bits
	# load LED value, get the desired bit in the loaded byte
	lbu  $t2,0($t0)
	srlv $t2,$t2,$t1    # shift LED value to lsb position
	andi $v0,$t2,0x3    # mask off any remaining upper bits
	jr   $ra

poll:	
	jal hasZombie1TimeElapsed #move zombie if time elapsed
	#jal hasZombie2TimeElapsed #move zombie if time elapsed
	#jal hasZombie3TimeElapsed #move zombie if time elapsed
	#jal hasZombie4TimeElapsed #move zombie if time elapsed
	jal checkCollision1
	jal checkCollision2
	jal checkCollision3
	jal checkCollision4
	
	beq $t9 4095 wonGame
	la	$v0,0xffff0000		# address for reading key press status
	lw	$t0,0($v0)		# read the key press status
	andi	$t0,$t0,1
	beq	$t0,$0,poll		# no key pressed
	lw	$t0,4($v0)		# read key value
	
	#check zombies times do shit accordingly
	
bkey:
	addi $v0, $t0 -66
	bne $v0, $0, rkey	
	jal drawBoard
	li $t9 0 #player position
	li $t7 0 #turn counter
	move $a0 $t9 #should probably hold this somewhere other than t9 DONT USE t9 FOR TEMP
	jal drawCharacter
	jal drawZombie1
	jal drawZombie2
	jal drawZombie3
	jal drawZombie4
	
	#start zombie times
	jal setZombie1TimeCurrent
	#jal setZombie2TimeCurrent
	#jal setZombie3TimeCurrent
	#jal setZombie4TimeCurrent
	

	j poll		
	
rkey:	addi	$v0,$t0,-227		# check for right key press
	bne	$v0,$0,lkey		# wasn't right key, so check for center
	#move char to right
	move $a0 $t9
	addi $a0 $a0 1 #add one for the if statement
	jal ifNextBlockWall
	beq $v0 0 poll #ifNextBlockWall returns false
	addi $a0 $a0 -1 #go back to original position to remove old character
	
	jal removeOldCharacter
	addi $t9 $t9 1
	move $a0 $t9	
	addi $t7 $t7 1
	li $v0 1
	syscall
	jal drawCharacter
	j	poll


lkey:	addi	$v0,$t0,-226		# check for right key press
	bne	$v0,$0,dkey		# wasn't right key, so check for center
	#move char to right
	move $a0 $t9
	addi $a0 $a0 -1
	jal ifNextBlockWall
	beq $v0 0 poll
	addi $a0 $a0 1
	
	jal removeOldCharacter
	addi $t9 $t9 -1
	move $a0 $t9
	#li $v0 1
	#syscall
	addi $t7 $t7 1
	jal drawCharacter		
	j	poll	

dkey:	addi	$v0,$t0,-225		# check for right key press
	bne	$v0,$0,ukey		# wasn't right key, so check for center
	#move char to right
	move $a0 $t9
	addi $a0 $a0 64
	jal ifNextBlockWall
	beq $v0 0 poll
	addi $a0 $a0 -64
	jal removeOldCharacter
	addi $t9 $t9 64
	move $a0 $t9
	#li $v0 1
	#syscall
	addi $t7 $t7 1
	jal drawCharacter
	j	poll	
	


ukey:	addi	$v0,$t0,-224		# check for right key press
	bne	$v0,$0,poll		# wasn't right key, so check for center
	#move char to right
	move $a0 $t9
	addi $a0 $a0 -64
	jal ifNextBlockWall
	beq $v0 0 poll
	addi $a0 $a0 64

	jal removeOldCharacter
	addi $t9 $t9 -64
	move $a0 $t9
	#li $v0 1
	#syscall
	addi $t7 $t7 1
	jal drawCharacter
	j	poll		

										

#takes next block in a0 as parameter	
ifNextBlockWall:
	addi $sp $sp -8
	sw $ra 0($sp)
	sw $t0 4($sp)
	move $t8 $a0
	#a0 is a number
	li $t0 64
	div $a0 $t0
	mflo $a1 
	mfhi $a0
	
	jal _getLED
	beq $v0 2 returnFalse
	j returnTrue
	

returnFalse:
	lw $ra 0($sp)
	lw $t0 4($sp)
	addi $sp $sp 8
	li $v0 0
	move $a0 $t8
	jr $ra
returnTrue:
	lw $ra 0($sp)
	lw $t0 4($sp)
	addi $sp $sp 8
	li $v0 1
	move $a0 $t8
	jr $ra
#a0 paramter
removeOldCharacter:
	addi $sp $sp -4
	sw $ra 0($sp)
	li $t0 64
	div $a0 $t0
	mflo $a1 
	mfhi $a0
	li $a2 0
	jal _setLED
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra

#a0 parameter for place
drawCharacter:
	addi $sp $sp -4
	sw $ra 0($sp)
	li $t0 64
	div $a0 $t0 
	mflo $a1 
	mfhi $a0
	li $a2 3
	jal _setLED

	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra

wonGame:
	la $a0 won
	li $v0 4
	syscall
	move $a0 $t7
	li $v0 1
	syscall
	la $a0 wonTurns
	li $v0 4
	syscall
	li $v0 10
	syscall
lostGame:
	la $a0 lost
	li $v0 4
	syscall
	li $v0 10
	syscall
	
#puts the time in $v0 
getTime:
	li $v0 30
	syscall
	sub $a0 $zero $a0 #time comes as negative number
	move $v0 $a0 
	jr $ra
	#syscall
	
#takes zombie time as parameter $a0
getTimeDifference:
	addi $sp $sp -4
	sw $ra 0($sp)
	
	move $s0 $a0 #move parameter time to $s0
		
	jal getTime
	move $s1 $v0 #current time is in s1 now
	sub $v0 $s0 $s1
		
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra


printNewLine:
	la $a0 newline
	li $v0 4
	syscall
	jr $ra

#number in $a0
printNumber:
	li $v0 1
	syscall
	jr $ra

#in retrospect should have made zombies current time an array. Ohwhale. modular programming is for chumps.	
setZombie1TimeCurrent:
	addi $sp $sp -4
	sw $ra 0($sp)
	jal getTime
	sw $a0 zombie1Time
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra

setZombie2TimeCurrent:
	addi $sp $sp -4
	sw $ra 0($sp)
	jal getTime
	sw $a0 zombie2Time
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra

setZombie3TimeCurrent:
	addi $sp $sp -4
	sw $ra 0($sp)
	jal getTime
	sw $a0 zombie3Time
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra
setZombie4TimeCurrent:
	addi $sp $sp -4
	sw $ra 0($sp)
	jal getTime
	sw $a0 zombie4Time
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra

#change this all zombies will have the same update times dont need 4 methods
hasZombie1TimeElapsed:
	addi $sp $sp -8
	sw $ra 0($sp)
	sw $s0 4($sp)
	
	la $s0 zombie1Time
	lw $s0 0($s0)
	move $a0 $s0
	jal getTimeDifference
	move $s0 $v0 
	blt $s0 500 returnFalseTime
	jal setZombie1TimeCurrent #save zombies time as current if worked
	#li $a0 1
	#li $v0 1
	#syscall
	j returnTrueTime

hasZombie2TimeElapsed:
	addi $sp $sp -8
	sw $ra 0($sp)
	sw $s0 4($sp)
	
	la $s0 zombie2Time
	lw $s0 0($s0)
	move $a0 $s0
	jal getTimeDifference
	move $s0 $v0 
	blt $s0 500 returnFalseTime
	jal setZombie2TimeCurrent #save zombies time as current if worked
	j returnTrueTime

hasZombie3TimeElapsed:
	addi $sp $sp -8
	sw $ra 0($sp)
	sw $s0 4($sp)
	
	la $s0 zombie3Time
	lw $s0 0($s0)
	move $a0 $s0
	jal getTimeDifference
	move $s0 $v0 
	blt $s0 500 returnFalseTime
	jal setZombie3TimeCurrent #save zombies time as current if worked
	j returnTrueTime

hasZombie4TimeElapsed:
	addi $sp $sp -8
	sw $ra 0($sp)
	sw $s0 4($sp)
	
	la $s0 zombie4Time
	lw $s0 0($s0)
	move $a0 $s0
	jal getTimeDifference
	move $s0 $v0 
	blt $s0 500 returnFalseTime
	jal setZombie4TimeCurrent #save zombies time as current if worked
	j returnTrueTime


returnTrueTime:
	jal moveZombie1
	lw $ra 0($sp)
	lw $s0 4($sp)
	addi $sp $sp 8
	li $v0 1
	jr $ra
	
returnFalseTime:
	lw $ra 0($sp)
	lw $s0 4($sp)
	addi $sp $sp 8
	li $v0 0
	jr $ra
	
drawZombie1:
	addi $sp $sp -4
	sw $ra 0($sp)
	
	la $t0 zombie1Position
	lw $t0 0($t0)
	li $t1 64
	div $t0 $t1
	mflo $a1 
	mfhi $a0
	li $a2 1
	jal _setLED
	
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra
	
drawZombie2:	
	addi $sp $sp -4
	sw $ra 0($sp)
	
	la $t0 zombie2Position
	lw $t0 0($t0)
	li $t1 64
	div $t0 $t1
	mflo $a1 
	mfhi $a0
	li $a2 1
	jal _setLED
	
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra
	
drawZombie3:
	addi $sp $sp -4
	sw $ra 0($sp)
	
	la $t0 zombie3Position
	lw $t0 0($t0)
	li $t1 64
	div $t0 $t1
	mflo $a1 
	mfhi $a0
	li $a2 1
	jal _setLED
	
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra
	
drawZombie4:
	addi $sp $sp -4
	sw $ra 0($sp)
	
	la $t0 zombie4Position
	lw $t0 0($t0)
	li $t1 64
	div $t0 $t1
	mflo $a1 
	mfhi $a0
	li $a2 1
	jal _setLED
	
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra

checkCollision1:
	addi $sp $sp -8
	sw $ra 0($sp)
	sw $s0 4($sp)
	#t9 is user
	
	la $s0 zombie1Position
	lw $s0 0($s0)
	beq $s0 $t9 lostGame
	
	lw $ra 0($sp)
	lw $s0 4($sp)
	addi $sp $sp 8
	
	jr $ra
checkCollision2:
	addi $sp $sp -8
	sw $ra 0($sp)
	sw $s0 4($sp)
	#t9 is user
	
	la $s0 zombie2Position
	lw $s0 0($s0)
	beq $s0 $t9 lostGame
	
	lw $ra 0($sp)
	lw $s0 4($sp)
	addi $sp $sp 8
	jr $ra

checkCollision3:
	addi $sp $sp -8
	sw $ra 0($sp)
	sw $s0 4($sp)
	#t9 is user
	
	la $s0 zombie3Position
	lw $s0 0($s0)
	beq $s0 $t9 lostGame
	
	lw $ra 0($sp)
	lw $s0 4($sp)
	addi $sp $sp 8
	
	jr $ra
checkCollision4:
	addi $sp $sp -8
	sw $ra 0($sp)
	sw $s0 4($sp)
	#t9 is user
	
	la $s0 zombie4Position
	lw $s0 0($s0)
	beq $s0 $t9 lostGame
	
	lw $ra 0($sp)
	lw $s0 4($sp)
	addi $sp $sp 8
	jr $ra

#return -64 up, 64 for down, -1 for left, 1 for right in $v0
getRandomZombieDirection:
	addi $sp $sp -4
	sw $ra 0($sp)
	jal getTime
	
	li $v0 42
	move $a0 $v0 #make random seed based off time (better for randomness)
	li $a1 4
	syscall
	
	
	#li $v0 1
	#syscall

	
	beq $a0 0 returnUp
	beq $a0 1 returnDown
	beq $a0 2 returnLeft
	beq $a0 3 returnRight	
	
	#this is here for testing when i comment out the if statements^^
	li $v0 0
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra
	
returnUp:
	li $v0 -64
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra
returnDown:
	li $v0 64
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra
returnLeft:
	li $v0 -1
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra
returnRight:
	li $v0 1
	lw $ra 0($sp)
	addi $sp $sp 4
	jr $ra

moveZombie1:
	addi $sp $sp -12
	sw $ra 0($sp)
	sw $s0 4($sp)
	sw $s1 8($sp)
	
	j moveZombie1LoopShit
	
moveZombie1LoopShit:
	
	jal getRandomZombieDirection
	move $a0 $v0
	#li $v0 1
	#syscall
	#jal printNewLine
	
	move $s0 $a0 #s0 contains next position
	la $s1 zombie1Position
	lw $s1 0($s1)
	add $a0 $s1 $s0 #get new position
	jal ifNextBlockWall
	
	
	beq $v0 0 moveZombie1LoopShit #find again if zombro is hitting a wall
	beq $a0 $s1 moveZombie1LoopShit 
	
	add $a0 $s1 $s0 #get new position since old values got clobbered
	
	jal zombie1CheckBounds
	beq $v0 0 moveZombie1LoopShit

	#add $a0 $s1 $s0 #got clobbered again by zombie1checkbounds
	
	
	move $a0 $s1
	jal removeOldCharacter #remove old characters position
	add $a0 $s1 $s0 #get new position
	
	la $s1 zombie1Position
	sw $a0 0($s1)
	
	li $t5 64
	div $a0 $t5
	mflo $a1 
	mfhi $a0
	li $a2 1
	jal _setLED

	
	lw $ra 0($sp)
	lw $s0 4($sp)
	lw $s1 8($sp)
	addi $sp $sp 12
	jr $ra

#takes a0 as next position, returns 0 if you cant move, 1 if you can
zombie1CheckBounds:
	addi $sp $sp -8
	sw $s0 0($sp)
	sw $s1 4($sp)
	
	#move $a0 $s0
	li $s1 64
	div $a0 $s1
	mflo $a1 
	mfhi $a0
	

	
	blt $a0 $0 zombie1BoundsReturnFalse
	bgt $a0 32 zombie1BoundsReturnFalse
	blt $a1 $0 zombie1BoundsReturnFalse
	bgt $a1 32 zombie1BoundsReturnFalse
	j zombie1BoundsReturnTrue
	
zombie1BoundsReturnFalse:
	lw $s0 0($sp)
	lw $s1 4($sp)
	addi $sp $sp 8
	
	li $v0 0
	jr $ra

zombie1BoundsReturnTrue:
	
	
	lw $s0 0($sp)
	lw $s1 4($sp)
	addi $sp $sp 8
	li $v0 1
	jr $ra

